// Copyright 2024 AI SA Assistant Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package synth provides synthesis functionality for the AI SA Assistant.
// It handles prompt building, LLM response parsing, and content extraction
// including Mermaid diagrams, code snippets, and source citations.
package synth

import (
	"fmt"
	"regexp"
	"strings"
	"unicode/utf8"
)

// ContextItem represents a piece of context with its source
type ContextItem struct {
	Content  string  `json:"content"`
	SourceID string  `json:"source_id"`
	Score    float64 `json:"score,omitempty"`
	Priority int     `json:"priority,omitempty"`
}

// QueryType represents the type of query for optimization
type QueryType int

const (
	// TechnicalQuery indicates queries focused on implementation and architecture
	TechnicalQuery QueryType = iota
	// BusinessQuery indicates queries focused on cost, ROI, and business value
	BusinessQuery
	// GeneralQuery indicates general-purpose queries
	GeneralQuery
)

// PromptConfig holds configuration for prompt generation
type PromptConfig struct {
	MaxTokens       int
	MaxContextItems int
	MaxWebResults   int
	QueryType       QueryType
}

// Configuration constants
const (
	DefaultMaxTokens       = 6000
	DefaultMaxContextItems = 10
	DefaultMaxWebResults   = 5
	MinimalPromptLength    = 100
	TokenEstimateRatio     = 4
	TruncationSafetyRatio  = 0.9
	MinCodeMatchGroups     = 3
	MinSourceMatchGroups   = 2
)

// DefaultPromptConfig returns default configuration
func DefaultPromptConfig() PromptConfig {
	return PromptConfig{
		MaxTokens:       DefaultMaxTokens,
		MaxContextItems: DefaultMaxContextItems,
		MaxWebResults:   DefaultMaxWebResults,
		QueryType:       GeneralQuery,
	}
}

// SynthesisRequest represents a request for synthesis
type SynthesisRequest struct {
	Query      string        `json:"query"`
	Context    []ContextItem `json:"context"`
	WebResults []string      `json:"web_results"`
}

// SynthesisResponse represents the structured response from synthesis
type SynthesisResponse struct {
	MainText     string        `json:"main_text"`
	DiagramCode  string        `json:"diagram_code"`
	CodeSnippets []CodeSnippet `json:"code_snippets"`
	Sources      []string      `json:"sources"`
}

// CodeSnippet represents a code snippet with its language
type CodeSnippet struct {
	Language string `json:"language"`
	Code     string `json:"code"`
}

// BuildPrompt combines context into a comprehensive prompt for the LLM
func BuildPrompt(query string, contextItems []ContextItem, webResults []string) string {
	config := DefaultPromptConfig()
	config.QueryType = DetectQueryType(query)
	return BuildPromptWithConfig(query, contextItems, webResults, config)
}

// BuildPromptWithConfig combines context into a comprehensive prompt with configuration
func BuildPromptWithConfig(query string, contextItems []ContextItem, webResults []string, config PromptConfig) string {
	// Prioritize and limit context based on token constraints
	optimizedContext := PrioritizeContext(contextItems, config.MaxContextItems)
	limitedWebResults := LimitWebResults(webResults, config.MaxWebResults)

	var prompt strings.Builder

	// System instructions based on query type
	systemPrompt := buildSystemPrompt(config.QueryType)
	prompt.WriteString(systemPrompt)

	// User query
	prompt.WriteString(fmt.Sprintf("User Query: %s\n\n", query))

	// Internal document context
	if len(optimizedContext) > 0 {
		prompt.WriteString("--- Internal Document Context ---\n")
		for i, item := range optimizedContext {
			prompt.WriteString(fmt.Sprintf("Context %d [%s]: %s\n\n", i+1, item.SourceID, item.Content))
		}
	}

	// Web search results
	if len(limitedWebResults) > 0 {
		prompt.WriteString("--- Live Web Search Results ---\n")
		for i, result := range limitedWebResults {
			prompt.WriteString(fmt.Sprintf("Web Result %d: %s\n\n", i+1, result))
		}
	}

	prompt.WriteString("\nPlease provide your comprehensive response now:")

	// Ensure token limits are respected
	finalPrompt := prompt.String()
	if EstimateTokens(finalPrompt) > config.MaxTokens {
		finalPrompt = TruncateToTokenLimit(finalPrompt, config.MaxTokens)
	}

	return finalPrompt
}

// ParseResponse parses the LLM response into structured components
func ParseResponse(response string) SynthesisResponse {
	result := SynthesisResponse{
		MainText:     response,
		CodeSnippets: []CodeSnippet{},
		Sources:      []string{},
	}

	// Extract diagram code
	if diagramCode := extractMermaidDiagram(response); diagramCode != "" {
		result.DiagramCode = diagramCode
		// Remove diagram from main text
		result.MainText = removeMermaidDiagram(response)
	}

	// Extract code snippets
	codeSnippets := extractCodeSnippets(response)
	result.CodeSnippets = codeSnippets
	// Remove code snippets from main text
	result.MainText = removeCodeSnippets(result.MainText)

	// Extract sources from citations
	sources := extractSources(response)
	result.Sources = uniqueStrings(sources)

	// Clean up main text
	result.MainText = strings.TrimSpace(result.MainText)

	return result
}

// extractMermaidDiagram extracts Mermaid diagram code from the response
func extractMermaidDiagram(response string) string {
	// Look for mermaid code blocks
	mermaidRegex := regexp.MustCompile("```mermaid\\s*\\n([\\s\\S]*?)\\n```")
	matches := mermaidRegex.FindStringSubmatch(response)

	if len(matches) > 1 {
		return strings.TrimSpace(matches[1])
	}

	// Also try without language identifier
	mermaidRegex2 := regexp.MustCompile("```\\s*\\n(graph\\s+TD[\\s\\S]*?)\\n```")
	matches2 := mermaidRegex2.FindStringSubmatch(response)

	if len(matches2) > 1 {
		return strings.TrimSpace(matches2[1])
	}

	return ""
}

// removeMermaidDiagram removes Mermaid diagram blocks from text
func removeMermaidDiagram(text string) string {
	mermaidRegex := regexp.MustCompile("```mermaid\\s*\\n[\\s\\S]*?\\n```")
	text = mermaidRegex.ReplaceAllString(text, "")

	mermaidRegex2 := regexp.MustCompile("```\\s*\\n(graph\\s+TD[\\s\\S]*?)\\n```")
	text = mermaidRegex2.ReplaceAllString(text, "")

	return text
}

// extractCodeSnippets extracts code snippets from the response
func extractCodeSnippets(response string) []CodeSnippet {
	var snippets []CodeSnippet

	// Regex to match code blocks with language identifiers
	codeRegex := regexp.MustCompile("```(\\w+)\\s*\\n([\\s\\S]*?)\\n```")
	matches := codeRegex.FindAllStringSubmatch(response, -1)

	for _, match := range matches {
		if len(match) >= MinCodeMatchGroups {
			language := match[1]
			code := strings.TrimSpace(match[2])

			// Skip mermaid blocks (handled separately)
			if language != "mermaid" && code != "" {
				snippets = append(snippets, CodeSnippet{
					Language: language,
					Code:     code,
				})
			}
		}
	}

	return snippets
}

// removeCodeSnippets removes code blocks from text
func removeCodeSnippets(text string) string {
	codeRegex := regexp.MustCompile("```\\w*\\s*\\n[\\s\\S]*?\\n```")
	return codeRegex.ReplaceAllString(text, "")
}

// extractSources extracts source citations from the response
func extractSources(response string) []string {
	var sources []string

	// Remove code blocks and mermaid diagrams first to avoid extracting node names
	textWithoutCode := removeCodeSnippets(response)
	textWithoutDiagrams := removeMermaidDiagram(textWithoutCode)

	// Regex to match [source_id] patterns
	sourceRegex := regexp.MustCompile(`\[([^\]]+)\]`)
	matches := sourceRegex.FindAllStringSubmatch(textWithoutDiagrams, -1)

	for _, match := range matches {
		if len(match) >= MinSourceMatchGroups {
			source := strings.TrimSpace(match[1])
			if source != "" {
				sources = append(sources, source)
			}
		}
	}

	return sources
}

// uniqueStrings removes duplicates from a string slice
func uniqueStrings(strings []string) []string {
	keys := make(map[string]bool)
	var unique []string

	for _, str := range strings {
		if !keys[str] {
			keys[str] = true
			unique = append(unique, str)
		}
	}

	return unique
}

// DetectFreshnessKeywords checks if the query contains keywords indicating need for fresh information
func DetectFreshnessKeywords(query string, keywords []string) bool {
	queryLower := strings.ToLower(query)

	for _, keyword := range keywords {
		if strings.Contains(queryLower, strings.ToLower(keyword)) {
			return true
		}
	}

	return false
}

// DetectQueryType analyzes the query to determine its type
func DetectQueryType(query string) QueryType {
	queryLower := strings.ToLower(query)

	// Technical query indicators
	technicalKeywords := []string{
		"architecture", "deploy", "configure", "implementation", "terraform",
		"aws", "azure", "gcp", "kubernetes", "docker", "microservices",
		"api", "database", "network", "security", "vpc", "subnet",
		"ec2", "s3", "lambda", "rds", "cloudformation", "ansible",
	}

	// Business query indicators
	businessKeywords := []string{
		"cost", "pricing", "roi", "budget", "savings", "business case",
		"timeline", "roadmap", "strategy", "compliance", "governance",
		"risk", "sla", "kpi", "metrics", "performance", "scalability",
	}

	technicalScore := 0
	businessScore := 0

	for _, keyword := range technicalKeywords {
		if strings.Contains(queryLower, keyword) {
			technicalScore++
		}
	}

	for _, keyword := range businessKeywords {
		if strings.Contains(queryLower, keyword) {
			businessScore++
		}
	}

	if technicalScore > businessScore {
		return TechnicalQuery
	} else if businessScore > technicalScore {
		return BusinessQuery
	}

	return GeneralQuery
}

// PrioritizeContext prioritizes and limits context items based on score and priority
func PrioritizeContext(contextItems []ContextItem, maxItems int) []ContextItem {
	// Sort by priority (higher first), then by score (higher first)
	sortedItems := make([]ContextItem, len(contextItems))
	copy(sortedItems, contextItems)

	// Simple bubble sort for priority and score
	for i := 0; i < len(sortedItems); i++ {
		for j := i + 1; j < len(sortedItems); j++ {
			if sortedItems[i].Priority < sortedItems[j].Priority ||
				(sortedItems[i].Priority == sortedItems[j].Priority && sortedItems[i].Score < sortedItems[j].Score) {
				sortedItems[i], sortedItems[j] = sortedItems[j], sortedItems[i]
			}
		}
	}

	// Return up to maxItems
	if len(sortedItems) > maxItems {
		return sortedItems[:maxItems]
	}
	return sortedItems
}

// LimitWebResults limits the number of web results
func LimitWebResults(webResults []string, maxResults int) []string {
	if len(webResults) <= maxResults {
		return webResults
	}
	return webResults[:maxResults]
}

// buildSystemPrompt creates system prompt based on query type
func buildSystemPrompt(queryType QueryType) string {
	basePrompt := `You are an expert Cloud Solutions Architect assistant. ` +
		`Your role is to help Solutions Architects with pre-sales research and planning.

Your response must be structured and comprehensive. Please provide:

1. A detailed, actionable answer to the user's query
2. If applicable, generate a high-level architecture diagram using Mermaid.js graph TD syntax
3. If applicable, provide relevant code snippets for implementation
4. Always cite your sources using [source_id] format when referencing internal documents

Guidelines:
- Be specific and actionable in your recommendations
- Include technical details and best practices
- For diagrams: Use Mermaid.js graph TD syntax enclosed in a "mermaid" code block
- For code: Use appropriate language identifiers (terraform, bash, yaml, etc.)
- Citations: End sentences with [source_id] when using information from internal documents
- Focus on practical implementation guidance

`

	diagramInstructions := buildDiagramInstructions(queryType)
	codeInstructions := buildCodeGenerationInstructions(queryType)

	switch queryType {
	case TechnicalQuery:
		technicalFocus := `TECHNICAL FOCUS: Emphasize technical implementation details, ` +
			`code examples, architectural patterns, and best practices. ` +
			`Provide specific configuration examples and troubleshooting guidance.

`
		return basePrompt + diagramInstructions + codeInstructions + technicalFocus
	case BusinessQuery:
		businessFocus := `BUSINESS FOCUS: Emphasize business value, cost considerations, ` +
			`ROI analysis, timeline estimates, and strategic implications. ` +
			`Include risk assessments and compliance considerations.

`
		return basePrompt + diagramInstructions + codeInstructions + businessFocus
	case GeneralQuery:
		return basePrompt + diagramInstructions + codeInstructions
	default:
		return basePrompt + diagramInstructions + codeInstructions
	}
}

// buildDiagramInstructions creates comprehensive Mermaid.js diagram generation instructions
func buildDiagramInstructions(_ QueryType) string {
	return `
## MERMAID.JS DIAGRAM GENERATION INSTRUCTIONS

### When to Generate Diagrams
Generate architecture diagrams for queries involving:
- Cloud architecture design (AWS, Azure, GCP, hybrid)
- Migration planning and lift-and-shift scenarios
- Disaster recovery and backup strategies
- Network topology and security configurations
- Microservices and containerization architectures
- CI/CD pipeline designs
- Data flow and integration patterns

### Mermaid Syntax Requirements
- ALWAYS use "graph TD" (Top-Down) syntax for cloud architecture diagrams
- Enclose ALL diagram code in triple backticks with "mermaid" language identifier: ` + "```mermaid" + `
- Use descriptive node names with proper formatting
- Include subgraphs for logical groupings (environments, regions, services)
- Use appropriate arrow styles for different connection types

### Cloud Architecture Diagram Conventions

#### AWS Architecture Diagrams
- Use subgraphs for VPCs, Availability Zones, and service groupings
- Node naming: Use AWS service names (EC2, RDS, S3, Lambda, etc.)
- Include security groups, subnets, and load balancers
- Show data flow with labeled arrows

Example AWS Pattern:
` + "```" + `
graph TD
    subgraph "AWS Cloud"
        subgraph "VPC: 10.0.0.0/16"
            subgraph "Public Subnet"
                ALB[Application Load Balancer]
                NAT[NAT Gateway]
            end
            subgraph "Private Subnet"
                EC2[EC2 Instances]
                RDS[RDS Database]
            end
        end
        S3[S3 Buckets]
    end
    Users[Users] --> ALB
    ALB --> EC2
    EC2 --> RDS
    EC2 --> S3
` + "```" + `

#### Azure Architecture Diagrams
- Use subgraphs for Resource Groups, Virtual Networks, and subscriptions
- Node naming: Use Azure service names (VM, SQL Database, Storage Account, etc.)
- Include Azure-specific components (Application Gateway, Traffic Manager)
- Show resource relationships and dependencies

Example Azure Pattern:
` + "```" + `
graph TD
    subgraph "Azure Subscription"
        subgraph "Resource Group: Production"
            subgraph "Virtual Network"
                AG[Application Gateway]
                VM[Virtual Machines]
                SQL[SQL Database]
            end
            SA[Storage Account]
        end
    end
    Internet[Internet] --> AG
    AG --> VM
    VM --> SQL
    VM --> SA
` + "```" + `

#### Hybrid Cloud Architecture Diagrams
- Clearly separate on-premises and cloud environments
- Show connection methods (VPN, ExpressRoute, Direct Connect)
- Include hybrid services and replication patterns
- Demonstrate data synchronization flows

Example Hybrid Pattern:
` + "```" + `
graph TD
    subgraph "On-Premises"
        DC[Data Center]
        AD[Active Directory]
        APP[Applications]
    end
    subgraph "AWS Cloud"
        VPC[VPC]
        EC2[EC2 Instances]
        RDS[RDS Database]
    end
    DC -.->|VPN Connection| VPC
    AD -.->|AD Connector| VPC
    APP --> EC2
    EC2 --> RDS
` + "```" + `

### Diagram Quality Requirements
- Include 5-15 nodes for optimal clarity
- Use meaningful node labels (not generic terms)
- Group related components in subgraphs
- Show clear data flow direction with arrows
- Include security boundaries and access controls
- Use consistent naming conventions throughout

### Node Formatting Guidelines
- Use PascalCase for service names: EC2, RDS, S3
- Use descriptive labels: "Web Servers" instead of "Servers"
- Include capacity or scale indicators when relevant
- Use square brackets for services: [EC2 Instances]
- Use parentheses for external entities: (Users)
- Use curly braces for databases: {RDS Database}

### Arrow Types and Meanings
- Solid arrows (-->) for primary data flow
- Dashed arrows (-.->)  for secondary or backup connections
- Thick arrows (==>) for high-bandwidth connections
- Dotted arrows (...>) for occasional or batch data transfer

### Fallback Instructions
If the query is NOT about architecture, infrastructure, or technical implementation:
- Do NOT generate a diagram
- Focus on textual response with bullet points and structured information
- Only include diagrams if they genuinely add value to the architectural understanding

### Common Diagram Mistakes to Avoid
- Do NOT use "graph LR" (Left-Right) - always use "graph TD" (Top-Down)
- Do NOT create overcomplicated diagrams with too many nodes
- Do NOT use generic node names like "Server1", "Database1"
- Do NOT forget to enclose diagram code in proper markdown code blocks
- Do NOT include diagrams for non-architectural queries

### Code Block Format
Always format Mermaid diagrams exactly like this:

` + "```mermaid" + `
graph TD
    [Your diagram content here]
` + "```" + `

`
}

// buildCodeGenerationInstructions creates comprehensive code generation instructions
func buildCodeGenerationInstructions(_ QueryType) string {
	var instructions strings.Builder

	instructions.WriteString(buildCodeGenerationHeader())
	instructions.WriteString(buildTerraformInstructions())
	instructions.WriteString(buildAWSCLIInstructions())
	instructions.WriteString(buildAzureCLIInstructions())
	instructions.WriteString(buildPowerShellInstructions())
	instructions.WriteString(buildCodeTestingInstructions())

	return instructions.String()
}

// buildCodeGenerationHeader creates the header section for code generation instructions
func buildCodeGenerationHeader() string {
	return `
## CODE GENERATION INSTRUCTIONS

### When to Generate Code
Generate code snippets for queries involving:
- Infrastructure deployment and configuration
- Cloud resource provisioning and management
- Migration and deployment automation
- Configuration management and orchestration
- Security implementations and compliance
- Monitoring, logging, and observability setup
- CI/CD pipeline configurations
- Backup, disaster recovery, and automation scripts

### Language and Tool Requirements

#### Terraform (Infrastructure as Code)
- Use for cloud infrastructure provisioning
- Include provider configuration (AWS, Azure, GCP)
- Use meaningful resource names with proper naming conventions
- Include data sources for existing resources
- Add variable definitions and output values
- Format: ` + "`terraform`" + `

Example Pattern:
` + "```terraform" + `
# Configure the AWS Provider
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Configure the AWS Provider
provider "aws" {
  region = var.aws_region
}

# Create VPC
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name        = "$${var.project_name}-vpc"
    Environment = var.environment
  }
}
` + "```" + `

#### AWS CLI Commands
- Use for AWS resource management and automation
- Include profile and region specifications where applicable
- Use meaningful output formats (json, table, text)
- Include error handling and validation
- Format: ` + "`bash`" + ` or ` + "`aws`" + `

Example Pattern:
` + "```bash" + `
#!/bin/bash
# AWS CLI script for EC2 instance management

# Set default region and profile
export AWS_DEFAULT_REGION=us-west-2
export AWS_PROFILE=production

# Create EC2 instance
aws ec2 run-instances \
  --image-id ami-0abcdef1234567890 \
  --instance-type t3.medium \
  --key-name my-key-pair \
  --security-group-ids sg-1234567890abcdef0 \
  --subnet-id subnet-12345678 \
  --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=WebServer},{Key=Environment,Value=Production}]' \
  --output table

# Wait for instance to be running
aws ec2 wait instance-running --instance-ids $${INSTANCE_ID}
echo "Instance $${INSTANCE_ID} is now running"
` + "```" + `

#### Azure CLI Commands
- Use for Azure resource management and automation
- Include subscription and resource group context
- Use meaningful output formats (json, table, yaml)
- Include error handling and resource validation
- Format: ` + "`bash`" + ` or ` + "`azurecli`" + `

Example Pattern:
` + "```bash" + `
#!/bin/bash
# Azure CLI script for VM deployment

# Set subscription and resource group
az account set --subscription "Production-Subscription"
RESOURCE_GROUP="myapp-prod-rg"
LOCATION="eastus"

# Create resource group if it doesn't exist
az group create --name $$RESOURCE_GROUP --location $$LOCATION

# Create virtual machine
az vm create \
  --resource-group $$RESOURCE_GROUP \
  --name myVM \
  --image Ubuntu2204 \
  --admin-username azureuser \
  --generate-ssh-keys \
  --size Standard_B2s \
  --tags Environment=Production Project=MyApp \
  --output table

# Open port 80 for web traffic
az vm open-port --port 80 --resource-group $$RESOURCE_GROUP --name myVM
` + "```" + `

#### PowerShell (Azure/Windows Automation)
- Use for Windows-based automation and Azure management
- Include proper error handling with try-catch blocks
- Use meaningful variable names and cmdlet parameters
- Include progress indicators for long-running operations
- Format: ` + "`powershell`" + ` or ` + "`ps1`" + `

Example Pattern:
` + "```powershell" + `
# PowerShell script for Azure resource deployment

# Import required modules
Import-Module Az.Accounts
Import-Module Az.Resources

# Connect to Azure (if not already connected)
if (-not (Get-AzContext)) {
    Connect-AzAccount
}

# Set variables
$$resourceGroupName = "myapp-prod-rg"
$$location = "East US"
$$vmName = "myappvm01"

try {
    # Create resource group
    Write-Host "Creating resource group: $$resourceGroupName" -ForegroundColor Green
    New-AzResourceGroup -Name $$resourceGroupName -Location $$location -Force

    # Create virtual machine
    Write-Host "Creating virtual machine: $$vmName" -ForegroundColor Green
    $$vm = New-AzVM ` + "`" + `
        -ResourceGroupName $$resourceGroupName ` + "`" + `
        -Name $$vmName ` + "`" + `
        -Location $$location ` + "`" + `
        -Size "Standard_B2s" ` + "`" + `
        -Image "Ubuntu2204" ` + "`" + `
        -OpenPorts 80,443,22 ` + "`" + `
        -PublicIpAddressName "$$vmName-pip" ` + "`" + `
        -SecurityGroupName "$$vmName-nsg"

    Write-Host "VM created successfully with IP: $$($$vm.PublicIpAddress)" -ForegroundColor Green
}
catch {
    Write-Error "Failed to create resources: $$($$_.Exception.Message)"
    exit 1
}
` + "```" + `

#### YAML/JSON Configuration Files
- Use for Kubernetes, Docker Compose, CI/CD pipelines
- Include proper indentation and structure
- Add comments explaining complex configurations
- Use meaningful names and labels
- Format: ` + "`yaml`" + `, ` + "`json`" + `, or ` + "`kubernetes`" + `

Example Pattern:
` + "```yaml" + `
# Kubernetes deployment configuration
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-deployment
  labels:
    app: webapp
    version: v1.0
spec:
  replicas: 3
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
      - name: webapp
        image: myregistry/webapp:latest
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
` + "```" + `

### Code Quality and Security Requirements

#### Security Best Practices
- NEVER include hardcoded secrets, API keys, passwords, or sensitive data
- Use environment variables, parameter stores, or secret management services
- Include proper IAM permissions and security group configurations
- Use least-privilege access principles
- Include encryption configurations where applicable

#### Code Quality Standards
- Include meaningful comments explaining complex logic
- Use consistent naming conventions throughout
- Add error handling and validation
- Include resource tagging for organization and cost tracking
- Use variables and parameters instead of hardcoded values
- Include outputs and return values where applicable

#### Documentation Requirements
- Add header comments explaining the purpose of each script
- Include usage examples and parameter descriptions
- Add inline comments for complex operations
- Include prerequisites and dependencies
- Add error handling explanations

### Conditional Code Generation Based on Platform

#### AWS-Specific Code
Generate when query mentions:
- AWS services (EC2, S3, RDS, Lambda, etc.)
- AWS deployment patterns
- AWS CLI operations
- AWS CloudFormation or CDK

#### Azure-Specific Code
Generate when query mentions:
- Azure services (VM, Storage Account, SQL Database, etc.)
- Azure deployment patterns
- Azure CLI or PowerShell operations
- Azure Resource Manager templates

#### Multi-Cloud or Hybrid Code
Generate when query mentions:
- Multi-cloud strategies
- Hybrid architectures
- Cloud-agnostic tools (Terraform, Kubernetes)
- Migration between platforms

### Code Block Formatting Requirements
- ALWAYS use triple backticks with appropriate language identifier
- Supported identifiers: terraform, bash, powershell, yaml, json, python, javascript
- Include file extensions in comments when applicable (e.g., # main.tf, # deploy.ps1)
- Use consistent indentation (2 spaces for YAML, 4 spaces for others)
- Include proper line breaks and spacing for readability

### Common Code Generation Patterns

#### Infrastructure Provisioning
- Include provider configuration
- Use data sources for existing resources
- Add proper tagging and naming conventions
- Include networking and security configurations

#### Automation Scripts
- Include error handling and logging
- Use meaningful variable names
- Add progress indicators for long operations
- Include cleanup and rollback procedures

#### Configuration Management
- Use configuration files with proper structure
- Include environment-specific configurations
- Add validation and testing steps
- Include backup and recovery procedures

### Fallback Instructions for Non-Technical Queries

#### When NOT to Generate Code
- Business strategy and planning queries
- High-level architectural discussions without implementation details
- Cost and pricing analysis requests
- Training and educational content requests
- Policy and compliance documentation requests

#### Alternative Response Patterns
For non-technical queries, provide:
- Structured bullet points with recommendations
- Best practices and guidelines
- Reference links and documentation pointers
- Process descriptions and workflows
- Timeline and planning considerations

### Code Comments and Documentation Standards

#### Header Comments for Scripts
` + "```bash" + `
#!/bin/bash
#
# Script: deploy-webapp.sh
# Purpose: Deploy web application to AWS ECS
# Author: Solutions Architect Team
# Version: 1.0
# Dependencies: AWS CLI v2, jq
# Usage: ./deploy-webapp.sh <environment> <image-tag>
#
` + "```" + `

#### Inline Comments for Complex Logic
` + "```terraform" + `
# Create internet gateway for public subnet access
resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "$${var.project_name}-igw"
  }
}

# Route table for public subnets to enable internet access
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  # Default route to internet gateway for outbound traffic
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }

  tags = {
    Name = "$${var.project_name}-public-rt"
  }
}
` + "```" + `

### Error Handling Patterns

#### Bash Error Handling
` + "```bash" + `
#!/bin/bash
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Function for error handling
error_exit() {
    echo "ERROR: $1" >&2
    exit 1
}

# Check if AWS CLI is installed
command -v aws >/dev/null 2>&1 || error_exit "AWS CLI is required but not installed"

# Validate required environment variables
: $${AWS_REGION:?AWS_REGION environment variable is required}
: $${ENVIRONMENT:?ENVIRONMENT environment variable is required}
` + "```" + `

#### PowerShell Error Handling
` + "```powershell" + `
# Set error action preference
$$ErrorActionPreference = "Stop"

try {
    # Main script logic here
    Write-Host "Starting deployment..." -ForegroundColor Green

    # Validate prerequisites
    if (-not (Get-Module -ListAvailable -Name Az)) {
        throw "Azure PowerShell module is required but not installed"
    }

    # Your deployment code here
}
catch {
    Write-Error "Deployment failed: $$($$_.Exception.Message)"
    Write-Host "Rolling back changes..." -ForegroundColor Yellow
    # Rollback logic here
    exit 1
}
finally {
    Write-Host "Cleanup completed" -ForegroundColor Blue
}
` + "```" + `

### Integration and Testing Considerations
- Include unit tests for complex scripts
- Add integration testing steps
- Include deployment validation checks
- Add monitoring and alerting configurations
- Include rollback and recovery procedures

`
}

// EstimateTokens provides a rough estimate of token count (4 characters â‰ˆ 1 token)
func EstimateTokens(text string) int {
	return utf8.RuneCountInString(text) / TokenEstimateRatio
}

// TruncateToTokenLimit truncates text to fit within token limit
func TruncateToTokenLimit(text string, maxTokens int) string {
	estimatedTokens := EstimateTokens(text)
	if estimatedTokens <= maxTokens {
		return text
	}

	// Calculate target character count (rough approximation)
	// Use safety ratio of the target to account for truncation notice
	targetChars := int(float64(maxTokens) * TokenEstimateRatio * TruncationSafetyRatio)
	runes := []rune(text)

	if len(runes) > targetChars {
		return string(runes[:targetChars]) + "...\n\n[Context truncated due to length limits]"
	}

	return text
}

// ValidatePrompt validates the completeness and structure of a prompt
func ValidatePrompt(prompt string) error {
	if err := validateBasicPromptStructure(prompt); err != nil {
		return err
	}

	if err := validatePromptContent(prompt); err != nil {
		return err
	}

	if err := validateDiagramInstructions(prompt); err != nil {
		return err
	}

	return validateCodeInstructions(prompt)
}

// validateBasicPromptStructure checks basic prompt requirements
func validateBasicPromptStructure(prompt string) error {
	if strings.TrimSpace(prompt) == "" {
		return fmt.Errorf("prompt cannot be empty")
	}

	if len(prompt) < MinimalPromptLength {
		return fmt.Errorf("prompt appears to be too short (< %d characters)", MinimalPromptLength)
	}

	return nil
}

// validatePromptContent checks for required content sections
func validatePromptContent(prompt string) error {
	requiredSections := map[string]string{
		"User Query:":         "user query section",
		"Solutions Architect": "Solutions Architect persona",
		"[source_id]":         "citation instructions",
	}

	for section, description := range requiredSections {
		if !strings.Contains(prompt, section) {
			return fmt.Errorf("prompt must contain %s", description)
		}
	}

	return nil
}

// validateDiagramInstructions checks for Mermaid diagram instruction requirements
func validateDiagramInstructions(prompt string) error {
	diagramRequirements := map[string]string{
		"MERMAID.JS DIAGRAM GENERATION INSTRUCTIONS": "Mermaid.js diagram generation instructions",
		"graph TD":                                   "graph TD syntax instructions",
		"```mermaid":                                 "mermaid code block formatting instructions",
	}

	for requirement, description := range diagramRequirements {
		if !strings.Contains(prompt, requirement) {
			return fmt.Errorf("prompt must contain %s", description)
		}
	}

	return nil
}

// validateCodeInstructions checks for code generation instruction requirements
func validateCodeInstructions(prompt string) error {
	codeRequirements := map[string]string{
		"CODE GENERATION INSTRUCTIONS":     "code generation instructions",
		"terraform":                        "Terraform code generation instructions",
		"AWS CLI":                          "AWS CLI code generation instructions",
		"Azure CLI":                        "Azure CLI code generation instructions",
		"PowerShell":                       "PowerShell code generation instructions",
		"NEVER include hardcoded secrets": "security requirements for code generation",
		"meaningful comments":              "code commenting requirements",
	}

	for requirement, description := range codeRequirements {
		if !strings.Contains(prompt, requirement) {
			return fmt.Errorf("prompt must contain %s", description)
		}
	}

	return nil
}

// DetectArchitectureQuery determines if a query is about architecture and warrants a diagram
func DetectArchitectureQuery(query string) bool {
	queryLower := strings.ToLower(query)

	architectureKeywords := []string{
		// Core architecture terms
		"architecture", "design", "topology", "infrastructure", "deployment",
		"migration", "lift-and-shift", "lift and shift", "disaster recovery",
		"backup", "replication", "failover", "high availability", "scalability",

		// Cloud platforms
		"aws", "azure", "gcp", "google cloud", "cloud", "hybrid", "multi-cloud",
		"on-premises", "on-prem", "datacenter", "data center",

		// Networking
		"network", "vpc", "subnet", "security group", "firewall", "load balancer",
		"vpn", "expressroute", "direct connect", "peering", "gateway",

		// Services and components
		"microservices", "containers", "kubernetes", "docker", "serverless",
		"lambda", "functions", "api", "database", "storage", "cdn",

		// Integration patterns
		"integration", "data flow", "pipeline", "workflow", "orchestration",
		"messaging", "queue", "event", "streaming", "batch processing",

		// Specific implementations
		"terraform", "cloudformation", "ansible", "ci/cd", "devops",
		"monitoring", "logging", "observability", "security", "compliance",
	}

	for _, keyword := range architectureKeywords {
		if strings.Contains(queryLower, keyword) {
			return true
		}
	}

	return false
}

// IsBusinessOnlyQuery determines if a query is purely business-focused without technical architecture
func IsBusinessOnlyQuery(query string) bool {
	queryLower := strings.ToLower(query)

	businessOnlyKeywords := []string{
		"cost", "pricing", "budget", "savings", "roi", "return on investment",
		"business case", "financial", "billing", "invoice", "payment",
		"timeline", "schedule", "project plan", "roadmap", "strategy",
		"compliance", "governance", "policy", "regulation", "audit",
		"risk", "security assessment", "vulnerability", "threat",
		"sla", "service level", "kpi", "metrics", "performance",
		"training", "certification", "documentation", "process",
		"team", "resources", "staffing", "skills", "expertise",
	}

	// Check if it's primarily business-focused
	businessScore := 0
	for _, keyword := range businessOnlyKeywords {
		if strings.Contains(queryLower, keyword) {
			businessScore++
		}
	}

	// If it has business keywords but no architecture keywords, it's business-only
	return businessScore > 0 && !DetectArchitectureQuery(query)
}
